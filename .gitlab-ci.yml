include:
  - local: ci-templates/test.gitlab-ci.yml
  - local: ci-templates/publish.gitlab-ci.yml
  - template: Workflows/MergeRequest-Pipelines.gitlab-ci.yml

build:
  before_script:
    - echo "before install poetry"
    - !reference [default, before_script]

test:
  script:
    - echo "example override"
    - !reference [.test, script]

publish:
  script:
    - echo "publish as $CI_COMMIT_TAG"

pages:
  rules:
    - if: $CI_COMMIT_TAG && $CI_PUSH_TOKEN
  variables:
    PAGES_BRANCH_NAME: pages
  before_script: []
  script:
    - pip install sphinx sphinx-immaterial
    - apt update && apt -qqy install git
    - sphinx-build -D version=$CI_COMMIT_TAG docs/source public/$CI_COMMIT_TAG
    - git config --global user.email $GITLAB_USER_EMAIL
    - git config --global user.name $GITLAB_USER_NAME
    - git remote set-url origin "https://${GITLAB_USER_NAME}:${CI_PUSH_TOKEN}@gitlab.com/$CI_PROJECT_PATH.git"
    - git branch -D $PAGES_BRANCH_NAME || true
    - git checkout --orphan $PAGES_BRANCH_NAME
    - git rm -rf .
    - |-
      if [[ $(git ls-remote --heads origin $PAGES_BRANCH_NAME) ]]; then
        echo "find existing branch '${PAGES_BRANCH_NAME}'";
        git pull origin $PAGES_BRANCH_NAME;
      else
        echo "no branch named '${PAGES_BRANCH_NAME}', do initialization";
        echo "[]" > public/versions.json
        echo "/${CI_PROJECT_NAME}/ /${CI_PROJECT_NAME}/${CI_COMMIT_TAG}" > public/_redirects
        python -c "import sys, yaml; branch_name = sys.argv[1]; yaml.safe_dump(dict(pages=dict(scripts=[], only=[branch_name], artifacts=dict(paths=['public']))), sys.stdout)" $PAGES_BRANCH_NAME > .gitlab-ci.yaml;
      fi
    - python -c "import json, sys; p, v = sys.argv[1:3]; lst = json.load(open(p)); new_ver = dict(version=v, title=v, aliases=[]); json.dump([new_ver, *lst], open(p, 'w'), indent=4)" public/versions.json $CI_COMMIT_TAG
    - git add public
    - git commit -m "Add version $CI_COMMIT_TAG"
    - git push --set-upstream origin $PAGES_BRANCH_NAME
  artifacts:
    paths:
    - public
